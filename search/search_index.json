{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Doc Como estruturar um projeto do Zero Este \u00e9 um projeto exemplo dedicado a demonstrar pr\u00e1ticas de refatora\u00e7\u00e3o. Neste espa\u00e7o, voc\u00ea encontrar\u00e1 uma descri\u00e7\u00e3o aprofundada da ETL, instru\u00e7\u00f5es para instala\u00e7\u00e3o, respostas a perguntas frequentes e mais. Seja voc\u00ea um colaborador ou simplesmente algu\u00e9m com interesse no projeto, esperamos que esta documenta\u00e7\u00e3o lhe seja \u00fatil. Al\u00e9m disso, esta documenta\u00e7\u00e3o pode ser integrada ao Confluence ou a uma intranet interna, facilitando o acesso e colabora\u00e7\u00e3o de todos os membros da equipe. Introdu\u00e7\u00e3o O objetivo deste projeto \u00e9 demonstrar como t\u00e9cnicas de refatora\u00e7\u00e3o podem ser aplicadas para melhorar a qualidade do c\u00f3digo, otimizar a performance e tornar o software mais manuten\u00edvel. A refatora\u00e7\u00e3o \u00e9 essencial para manter o c\u00f3digo limpo e compreens\u00edvel, permitindo que equipes mantenham uma alta velocidade de desenvolvimento ao longo do tempo. Guia de Instala\u00e7\u00e3o Aqui, voc\u00ea encontrar\u00e1 instru\u00e7\u00f5es detalhadas sobre como instalar e configurar o projeto em seu ambiente local. Seguir as instru\u00e7\u00f5es corretamente garante que voc\u00ea tenha uma experi\u00eancia suave ao trabalhar no projeto. FAQ Esta se\u00e7\u00e3o fornece respostas para perguntas frequentes. Se voc\u00ea tiver alguma d\u00favida que n\u00e3o est\u00e1 coberta aqui, sinta-se \u00e0 vontade para entrar em contato.","title":"Home"},{"location":"#doc-como-estruturar-um-projeto-do-zero","text":"Este \u00e9 um projeto exemplo dedicado a demonstrar pr\u00e1ticas de refatora\u00e7\u00e3o. Neste espa\u00e7o, voc\u00ea encontrar\u00e1 uma descri\u00e7\u00e3o aprofundada da ETL, instru\u00e7\u00f5es para instala\u00e7\u00e3o, respostas a perguntas frequentes e mais. Seja voc\u00ea um colaborador ou simplesmente algu\u00e9m com interesse no projeto, esperamos que esta documenta\u00e7\u00e3o lhe seja \u00fatil. Al\u00e9m disso, esta documenta\u00e7\u00e3o pode ser integrada ao Confluence ou a uma intranet interna, facilitando o acesso e colabora\u00e7\u00e3o de todos os membros da equipe.","title":"Doc Como estruturar um projeto do Zero"},{"location":"#introducao","text":"O objetivo deste projeto \u00e9 demonstrar como t\u00e9cnicas de refatora\u00e7\u00e3o podem ser aplicadas para melhorar a qualidade do c\u00f3digo, otimizar a performance e tornar o software mais manuten\u00edvel. A refatora\u00e7\u00e3o \u00e9 essencial para manter o c\u00f3digo limpo e compreens\u00edvel, permitindo que equipes mantenham uma alta velocidade de desenvolvimento ao longo do tempo.","title":"Introdu\u00e7\u00e3o"},{"location":"#guia-de-instalacao","text":"Aqui, voc\u00ea encontrar\u00e1 instru\u00e7\u00f5es detalhadas sobre como instalar e configurar o projeto em seu ambiente local. Seguir as instru\u00e7\u00f5es corretamente garante que voc\u00ea tenha uma experi\u00eancia suave ao trabalhar no projeto.","title":"Guia de Instala\u00e7\u00e3o"},{"location":"#faq","text":"Esta se\u00e7\u00e3o fornece respostas para perguntas frequentes. Se voc\u00ea tiver alguma d\u00favida que n\u00e3o est\u00e1 coberta aqui, sinta-se \u00e0 vontade para entrar em contato.","title":"FAQ"},{"location":"api/","text":"API Documentation Abaixo, voc\u00ea encontrar\u00e1 detalhes sobre as fun\u00e7\u00f5es e m\u00f3dulos do nosso projeto. M\u00f3dulo Pipeline Extract fun\u00e7\u00e3o para ler os arquivos de uma pasta em path e retornar uma lista de DataFrames args: input_path (str): caminho da pasta para extra\u00e7\u00e3o return: df_list: lista de DataFrames Source code in src/pipeline/extract.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def extract_from_excels_folder ( path : list [ str ]) -> list [ pd . DataFrame ]: \"\"\" fun\u00e7\u00e3o para ler os arquivos de uma pasta em path e retornar uma lista de DataFrames args: input_path (str): caminho da pasta para extra\u00e7\u00e3o return: df_list: lista de DataFrames \"\"\" full_path = os . path . join ( * path , \"*.xlsx\" ) path_files = glob . glob ( full_path ) dataframes = [ pd . read_excel ( file ) for file in path_files ] return dataframes Transform Fun\u00e7\u00e3o que transforma uma lista de DataFrames em um DataFrame unido. Source code in src/pipeline/transform.py 4 5 6 7 8 9 def concat_dataframes ( dataframes : list [ pd . DataFrame ]) -> pd . DataFrame : \"\"\" Fun\u00e7\u00e3o que transforma uma lista de DataFrames em um DataFrame unido. \"\"\" concated_df = pd . concat ( dataframes , ignore_index = True ) return concated_df Load Salva um DataFrame no formato Excel (xlsx) args: df: pd.DataFrame: Dataframe que ser\u00e1 salvo em Excel filename: str: nome do arquivo que ser\u00e1 gerado. path: list[str]: caminho que ser\u00e1 usado para salvar o arquivo. Source code in src/pipeline/load.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def load_to_excel ( df : pd . DataFrame , filename : str , path : list [ str ]): \"\"\" Salva um DataFrame no formato Excel (xlsx) args: df: pd.DataFrame: Dataframe que ser\u00e1 salvo em Excel filename: str: nome do arquivo que ser\u00e1 gerado. path: list[str]: caminho que ser\u00e1 usado para salvar o arquivo. \"\"\" folder_path = os . path . join ( * path ) if not os . path . exists ( folder_path ): os . makedirs ( folder_path ) full_path = os . path . join ( folder_path , f \" { filename } .xlsx\" ) df . to_excel ( full_path , index = False )","title":"API"},{"location":"api/#api-documentation","text":"Abaixo, voc\u00ea encontrar\u00e1 detalhes sobre as fun\u00e7\u00f5es e m\u00f3dulos do nosso projeto.","title":"API Documentation"},{"location":"api/#modulo-pipeline","text":"","title":"M\u00f3dulo Pipeline"},{"location":"api/#extract","text":"fun\u00e7\u00e3o para ler os arquivos de uma pasta em path e retornar uma lista de DataFrames args: input_path (str): caminho da pasta para extra\u00e7\u00e3o return: df_list: lista de DataFrames Source code in src/pipeline/extract.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def extract_from_excels_folder ( path : list [ str ]) -> list [ pd . DataFrame ]: \"\"\" fun\u00e7\u00e3o para ler os arquivos de uma pasta em path e retornar uma lista de DataFrames args: input_path (str): caminho da pasta para extra\u00e7\u00e3o return: df_list: lista de DataFrames \"\"\" full_path = os . path . join ( * path , \"*.xlsx\" ) path_files = glob . glob ( full_path ) dataframes = [ pd . read_excel ( file ) for file in path_files ] return dataframes","title":"Extract"},{"location":"api/#transform","text":"Fun\u00e7\u00e3o que transforma uma lista de DataFrames em um DataFrame unido. Source code in src/pipeline/transform.py 4 5 6 7 8 9 def concat_dataframes ( dataframes : list [ pd . DataFrame ]) -> pd . DataFrame : \"\"\" Fun\u00e7\u00e3o que transforma uma lista de DataFrames em um DataFrame unido. \"\"\" concated_df = pd . concat ( dataframes , ignore_index = True ) return concated_df","title":"Transform"},{"location":"api/#load","text":"Salva um DataFrame no formato Excel (xlsx) args: df: pd.DataFrame: Dataframe que ser\u00e1 salvo em Excel filename: str: nome do arquivo que ser\u00e1 gerado. path: list[str]: caminho que ser\u00e1 usado para salvar o arquivo. Source code in src/pipeline/load.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def load_to_excel ( df : pd . DataFrame , filename : str , path : list [ str ]): \"\"\" Salva um DataFrame no formato Excel (xlsx) args: df: pd.DataFrame: Dataframe que ser\u00e1 salvo em Excel filename: str: nome do arquivo que ser\u00e1 gerado. path: list[str]: caminho que ser\u00e1 usado para salvar o arquivo. \"\"\" folder_path = os . path . join ( * path ) if not os . path . exists ( folder_path ): os . makedirs ( folder_path ) full_path = os . path . join ( folder_path , f \" { filename } .xlsx\" ) df . to_excel ( full_path , index = False )","title":"Load"},{"location":"structure/","text":"Ambiente de Desenvolvimento 1. Python Version ( Pyenv ) A vers\u00e3o do Python \u00e9 um dos primeiros pontos importantes de se notar quando estamos come\u00e7ando um projeto ou assumindo um projeto legado. Principalmente pelo fato de que o Python s\u00f3 se compromete a fazer corre\u00e7\u00f5es de 3 vers\u00f5es anteriores ex: (3.12 (atual), 3.11 e 3.10), sendo assim um projeto anterior pode apresentar riscos de vulnerabilidades! Para garantir a vers\u00e3o do Python o ideal \u00e9 termos um arquivo .python-version no projeto, o ideal \u00e9 usar uma solu\u00e7\u00e3o de Env como pyenv para isso. 2. Project ENV ( Poetry ) Outro problema comum quando lidamos com projetos Python \u00e9 criarmos projetos em que depend\u00eancias podem variar dependendo do desenvolvedor, ou ainda, um mesmo desenvolvedor lidar com projetos distintos. Por\u00e9m, podemos fazer isso apenas usando venv , ou usando solu\u00e7\u00f5es mais complexas como o Poetry . Atualmente, o mais usado \u00e9 o Poetry pois ele facilita o setup de projetos e torna sua estrutura mais concisa. Para iniciar um projeto com Poetry : poetry init Para definir a vers\u00e3o do Python e criar um venv inicial (OBRIGAT\u00d3RIO!) : poetry env use <version> 3. GIT e GitHub O uso de ferramentas de versionamento \u00e9 algo excencial para conseguir ter o controle do projeto, do desenvolvimento do que foi feito e ter uma organiza\u00e7\u00e3o melhor. Importante notar que o GIT funciona bem para arquivos de texto, como arquivos com c\u00f3digo, n\u00e3o arquivos bin\u00e1rios. Al\u00e9m disso, ferramentas como GitHub s\u00e3o servi\u00e7os de \"hospedagem\" de projetos GIT, quase como um YouTube, que \u00e9 usado para hospedar v\u00eddeos. Al\u00e9m disso, podemos usar ferramentas de CI/CD para que os projetos controlados no Git sejam integrados de forma mais simples e tenham menos chance de falha ao ocorrerem atualiza\u00e7\u00f5es, isso pode ser feito por Hooks. .gitignore Um dos pontos comuns em projetos que usam git \u00e9 termos arquivos que n\u00e3o queremos que sejam salvos no git, seja por seu tamanho ou por n\u00e3o serem necess\u00e1rios, para isso criamos o GitIgnore. Por\u00e9m, como cri\u00e1-lo na m\u00e3o pode ser complexo podemos usar ferramentas como o gitignore.io , que j\u00e1 nos tr\u00e1s uma lista pronta, com base na tecnologia utilizada (por exemplo, Python). Qualidade de C\u00f3digo 1. Testes (pytest) O conceito de testes unit\u00e1rios e testes de integra\u00e7\u00e3o \u00e9 algo muito importante, pois garante ao desenvolvedor seguran\u00e7a na hora de fazer uma implementa\u00e7\u00e3o ou altera\u00e7\u00e3o em um c\u00f3digo. Quando criamos testes unit\u00e1rios testamos uma funcionalidade de forma isolada e seus poss\u00edveis resultados, podendo definir uma ou mais premissas que podem ser verdadeiras. para rodar os testes usamos o pytest . J\u00e1 testes de integra\u00e7\u00e3o testam como diferentes peda\u00e7os de um c\u00f3digo interagem, sendo uma solu\u00e7\u00e3o para testar de forma mais complexa. Importante notar que devemos focar mais em testes unit\u00e1rios que em testes de integra\u00e7\u00e3o, por serem mais importantes e simples de serem feitos. 2. Padr\u00f5es de Projeto (Ex: ISort, Blue e Pydocstyle) Conceito em que aderimos o projeto a alguns padr\u00f5es pr\u00e9-determinados e mais conhecidos, como as PEPs, usado para que o time n\u00e3o \"perca tempo\" definindo padr\u00f5es que j\u00e1 foram definidos antes. Muitas dessas bibliotecas ainda auxiliam para que n\u00e3o seja necess\u00e1rio corrigirmos os erros, corrigindo diretamente tudo que est\u00e1 fora do padr\u00e3o. Muitas dessas bibliotecas rodam apenas com o nome da lib, ou ainda o nome da lib e quais arquivos devem ser tocados. Como em pydocstyle e isort . (usa isort em todos os arquivos). 3. Tarefas (Taskipy) Algo comum em projetos \u00e9 termos diferentes comandos que precisam ser executados para situa\u00e7\u00f5es diferentes, scripts para rodar o c\u00f3digo, scripts de setup, scripts para testes, para documenta\u00e7\u00e3o.... O grande problema \u00e9 que esses comandos podem n\u00e3o ser triviais, quando adicionamos uma ferramenta de tarefas simplificamos o projeto, podendo usar algo como task run para rodar o projeto, sem precisar se preocupar com qual arquivo deve ser executado, ou qual comando. Para isso s\u00f3 precisamos adicionar a biblioteca taskipy e criar as tasks que podem ser usadas, como por exemplo (deve ser adicionado no pyproject.toml): [tool.taskipy.tasks] run = \"python src\" lint = \"isort . && blue .\" test = \"pytest -v \" 4. Documenta\u00e7\u00e3o (MKDocs) Uma documenta\u00e7\u00e3o tr\u00e1s mais profissionalismo ao projeto e clareza sobre a composi\u00e7\u00e3o do projeto. Quando criamos a doc com o MKDocs conseguimos criar uma doc mais robusta, como uma aplica\u00e7\u00e3o a parte que pode ser publicada e ficar p\u00fablica ou privada (a depender da necessidade). Quando precisamos mapear as funcionalidades do projeto podemos usar o mkdocstrings , usado para referenciar as fun\u00e7\u00f5es ou classes da aplica\u00e7\u00e3o. Sempre importante lembrar que o mkdocs usa MD, sendo uma estrutura simples de ser escrita. Alguns comandos importantes Criar uma doc nova: mkdocs new . Subir o server com a doc: mkdocs serve Buildar a doc, usado para publicar o site de outras formas: mkdocs build Publicar a doc no GitHub Pages: mkdocs gh-deploy Pluggins \u00dateis: mkdocstrings-python pygments mkdocs-material pymdown-extensions mkdocs-bootstrap38 Mermaid Como o MKDocs usa MDs para cria\u00e7\u00e3o das p\u00e1ginas, sendo assim estruturas como a que temos abaixo s\u00e3o poss\u00edveis, ou outras op\u00e7\u00f5es usando MD. graph TD; A-->B; A-->C; B-->D; C-->D; 5. Git Hooks (Pre-commit) Quando queremos que o projeto mantenha certos padr\u00f5es acordados uma boa sa\u00edda \u00e9 um git hook, esse tipo de funcionalidade faz com que fun\u00e7\u00f5es sejam executadas toda vez que um c\u00f3digo novo vai ser commitado. Para isso usamos o pre-commit , criamos um arquivo .pre-commit-config.yaml , configuramos esse arquivo da forma que quisermos e depois usamos o pre-commit install para que as configura\u00e7\u00f5es sejam instaladas dentro do .git/hooks de forma autom\u00e1tica. Uma vez que esse processo for feito toda vez que formos fazer um commit esse hook ser\u00e1 ativo e com ele todas as suas fun\u00e7\u00f5es. Para rodarmos o pre-commit em todo o projeto, ent\u00e3o analisando toda a base de c\u00f3digo j\u00e1 existente usamos o pre-commit run -a , dessa forma garantindo a qualidade da code base. 6. CI (GitHub Actions) O processo de CI garante que o c\u00f3digo seja validado durante o processo de integra\u00e7\u00e3o, dessa forma agilizando alguns testes que garantem a qualidade de c\u00f3digo. Esse processo pode ser atrelado a a\u00e7\u00f5es no reposit\u00f3rio, como push, pull_request . Com isso garantimos uma qualidade maior no c\u00f3digo que est\u00e1 no reposit\u00f3rio. Para usarmos o GH Actions criamos um arquivo .yml dentro de uma pasta .github/workflows . Com isso garantimos uma s\u00e9rie de steps que ser\u00e1 feito em uma m\u00e1quina virtual garantindo que o c\u00f3digo esteja com qualidade. README O README n\u00e3o \u00e9 um pr\u00e9-requisito em projetos, mas sim uma \u00f3tima pr\u00e1tica para podermos passar informa\u00e7\u00f5es sobre o projeto. Alguns dos pontos mais importantes para um README s\u00e3o: Descri\u00e7\u00e3o do projeto e motivador. Processo de Setup Principais comandos do projeto Documenta\u00e7\u00e3o, ou link para documenta\u00e7\u00e3o (em caso da doc hospedada) Contato.","title":"Estrutura"},{"location":"structure/#ambiente-de-desenvolvimento","text":"","title":"Ambiente de Desenvolvimento"},{"location":"structure/#1-python-version-pyenv","text":"A vers\u00e3o do Python \u00e9 um dos primeiros pontos importantes de se notar quando estamos come\u00e7ando um projeto ou assumindo um projeto legado. Principalmente pelo fato de que o Python s\u00f3 se compromete a fazer corre\u00e7\u00f5es de 3 vers\u00f5es anteriores ex: (3.12 (atual), 3.11 e 3.10), sendo assim um projeto anterior pode apresentar riscos de vulnerabilidades! Para garantir a vers\u00e3o do Python o ideal \u00e9 termos um arquivo .python-version no projeto, o ideal \u00e9 usar uma solu\u00e7\u00e3o de Env como pyenv para isso.","title":"1. Python Version (Pyenv)"},{"location":"structure/#2-project-env-poetry","text":"Outro problema comum quando lidamos com projetos Python \u00e9 criarmos projetos em que depend\u00eancias podem variar dependendo do desenvolvedor, ou ainda, um mesmo desenvolvedor lidar com projetos distintos. Por\u00e9m, podemos fazer isso apenas usando venv , ou usando solu\u00e7\u00f5es mais complexas como o Poetry . Atualmente, o mais usado \u00e9 o Poetry pois ele facilita o setup de projetos e torna sua estrutura mais concisa. Para iniciar um projeto com Poetry : poetry init Para definir a vers\u00e3o do Python e criar um venv inicial (OBRIGAT\u00d3RIO!) : poetry env use <version>","title":"2. Project ENV (Poetry)"},{"location":"structure/#3-git-e-github","text":"O uso de ferramentas de versionamento \u00e9 algo excencial para conseguir ter o controle do projeto, do desenvolvimento do que foi feito e ter uma organiza\u00e7\u00e3o melhor. Importante notar que o GIT funciona bem para arquivos de texto, como arquivos com c\u00f3digo, n\u00e3o arquivos bin\u00e1rios. Al\u00e9m disso, ferramentas como GitHub s\u00e3o servi\u00e7os de \"hospedagem\" de projetos GIT, quase como um YouTube, que \u00e9 usado para hospedar v\u00eddeos. Al\u00e9m disso, podemos usar ferramentas de CI/CD para que os projetos controlados no Git sejam integrados de forma mais simples e tenham menos chance de falha ao ocorrerem atualiza\u00e7\u00f5es, isso pode ser feito por Hooks.","title":"3. GIT e GitHub"},{"location":"structure/#gitignore","text":"Um dos pontos comuns em projetos que usam git \u00e9 termos arquivos que n\u00e3o queremos que sejam salvos no git, seja por seu tamanho ou por n\u00e3o serem necess\u00e1rios, para isso criamos o GitIgnore. Por\u00e9m, como cri\u00e1-lo na m\u00e3o pode ser complexo podemos usar ferramentas como o gitignore.io , que j\u00e1 nos tr\u00e1s uma lista pronta, com base na tecnologia utilizada (por exemplo, Python).","title":".gitignore"},{"location":"structure/#qualidade-de-codigo","text":"","title":"Qualidade de C\u00f3digo"},{"location":"structure/#1-testes-pytest","text":"O conceito de testes unit\u00e1rios e testes de integra\u00e7\u00e3o \u00e9 algo muito importante, pois garante ao desenvolvedor seguran\u00e7a na hora de fazer uma implementa\u00e7\u00e3o ou altera\u00e7\u00e3o em um c\u00f3digo. Quando criamos testes unit\u00e1rios testamos uma funcionalidade de forma isolada e seus poss\u00edveis resultados, podendo definir uma ou mais premissas que podem ser verdadeiras. para rodar os testes usamos o pytest . J\u00e1 testes de integra\u00e7\u00e3o testam como diferentes peda\u00e7os de um c\u00f3digo interagem, sendo uma solu\u00e7\u00e3o para testar de forma mais complexa. Importante notar que devemos focar mais em testes unit\u00e1rios que em testes de integra\u00e7\u00e3o, por serem mais importantes e simples de serem feitos.","title":"1. Testes (pytest)"},{"location":"structure/#2-padroes-de-projeto-ex-isort-blue-e-pydocstyle","text":"Conceito em que aderimos o projeto a alguns padr\u00f5es pr\u00e9-determinados e mais conhecidos, como as PEPs, usado para que o time n\u00e3o \"perca tempo\" definindo padr\u00f5es que j\u00e1 foram definidos antes. Muitas dessas bibliotecas ainda auxiliam para que n\u00e3o seja necess\u00e1rio corrigirmos os erros, corrigindo diretamente tudo que est\u00e1 fora do padr\u00e3o. Muitas dessas bibliotecas rodam apenas com o nome da lib, ou ainda o nome da lib e quais arquivos devem ser tocados. Como em pydocstyle e isort . (usa isort em todos os arquivos).","title":"2. Padr\u00f5es de Projeto (Ex: ISort, Blue e Pydocstyle)"},{"location":"structure/#3-tarefas-taskipy","text":"Algo comum em projetos \u00e9 termos diferentes comandos que precisam ser executados para situa\u00e7\u00f5es diferentes, scripts para rodar o c\u00f3digo, scripts de setup, scripts para testes, para documenta\u00e7\u00e3o.... O grande problema \u00e9 que esses comandos podem n\u00e3o ser triviais, quando adicionamos uma ferramenta de tarefas simplificamos o projeto, podendo usar algo como task run para rodar o projeto, sem precisar se preocupar com qual arquivo deve ser executado, ou qual comando. Para isso s\u00f3 precisamos adicionar a biblioteca taskipy e criar as tasks que podem ser usadas, como por exemplo (deve ser adicionado no pyproject.toml): [tool.taskipy.tasks] run = \"python src\" lint = \"isort . && blue .\" test = \"pytest -v \"","title":"3. Tarefas (Taskipy)"},{"location":"structure/#4-documentacao-mkdocs","text":"Uma documenta\u00e7\u00e3o tr\u00e1s mais profissionalismo ao projeto e clareza sobre a composi\u00e7\u00e3o do projeto. Quando criamos a doc com o MKDocs conseguimos criar uma doc mais robusta, como uma aplica\u00e7\u00e3o a parte que pode ser publicada e ficar p\u00fablica ou privada (a depender da necessidade). Quando precisamos mapear as funcionalidades do projeto podemos usar o mkdocstrings , usado para referenciar as fun\u00e7\u00f5es ou classes da aplica\u00e7\u00e3o. Sempre importante lembrar que o mkdocs usa MD, sendo uma estrutura simples de ser escrita.","title":"4. Documenta\u00e7\u00e3o (MKDocs)"},{"location":"structure/#alguns-comandos-importantes","text":"Criar uma doc nova: mkdocs new . Subir o server com a doc: mkdocs serve Buildar a doc, usado para publicar o site de outras formas: mkdocs build Publicar a doc no GitHub Pages: mkdocs gh-deploy","title":"Alguns comandos importantes"},{"location":"structure/#pluggins-uteis","text":"mkdocstrings-python pygments mkdocs-material pymdown-extensions mkdocs-bootstrap38","title":"Pluggins \u00dateis:"},{"location":"structure/#mermaid","text":"Como o MKDocs usa MDs para cria\u00e7\u00e3o das p\u00e1ginas, sendo assim estruturas como a que temos abaixo s\u00e3o poss\u00edveis, ou outras op\u00e7\u00f5es usando MD. graph TD; A-->B; A-->C; B-->D; C-->D;","title":"Mermaid"},{"location":"structure/#5-git-hooks-pre-commit","text":"Quando queremos que o projeto mantenha certos padr\u00f5es acordados uma boa sa\u00edda \u00e9 um git hook, esse tipo de funcionalidade faz com que fun\u00e7\u00f5es sejam executadas toda vez que um c\u00f3digo novo vai ser commitado. Para isso usamos o pre-commit , criamos um arquivo .pre-commit-config.yaml , configuramos esse arquivo da forma que quisermos e depois usamos o pre-commit install para que as configura\u00e7\u00f5es sejam instaladas dentro do .git/hooks de forma autom\u00e1tica. Uma vez que esse processo for feito toda vez que formos fazer um commit esse hook ser\u00e1 ativo e com ele todas as suas fun\u00e7\u00f5es. Para rodarmos o pre-commit em todo o projeto, ent\u00e3o analisando toda a base de c\u00f3digo j\u00e1 existente usamos o pre-commit run -a , dessa forma garantindo a qualidade da code base.","title":"5. Git Hooks (Pre-commit)"},{"location":"structure/#6-ci-github-actions","text":"O processo de CI garante que o c\u00f3digo seja validado durante o processo de integra\u00e7\u00e3o, dessa forma agilizando alguns testes que garantem a qualidade de c\u00f3digo. Esse processo pode ser atrelado a a\u00e7\u00f5es no reposit\u00f3rio, como push, pull_request . Com isso garantimos uma qualidade maior no c\u00f3digo que est\u00e1 no reposit\u00f3rio. Para usarmos o GH Actions criamos um arquivo .yml dentro de uma pasta .github/workflows . Com isso garantimos uma s\u00e9rie de steps que ser\u00e1 feito em uma m\u00e1quina virtual garantindo que o c\u00f3digo esteja com qualidade.","title":"6. CI (GitHub Actions)"},{"location":"structure/#readme","text":"O README n\u00e3o \u00e9 um pr\u00e9-requisito em projetos, mas sim uma \u00f3tima pr\u00e1tica para podermos passar informa\u00e7\u00f5es sobre o projeto. Alguns dos pontos mais importantes para um README s\u00e3o: Descri\u00e7\u00e3o do projeto e motivador. Processo de Setup Principais comandos do projeto Documenta\u00e7\u00e3o, ou link para documenta\u00e7\u00e3o (em caso da doc hospedada) Contato.","title":"README"}]}